# Data Model: Collaborative To-Do Application

**Feature**: 001-collab-todo-link  
**Date**: 2026-01-05  
**Database**: MongoDB

## Overview

The data model consists of two primary collections: `TodoList` and `TodoItem`. The design is normalized to allow efficient querying, updating, and scaling. All entities use MongoDB ObjectIds as primary identifiers per the project constitution.

---

## Collections

### TodoList Collection

**Purpose**: Stores metadata for each shareable to-do list.

**Schema**:

```typescript
interface TodoListDocument {
  _id: ObjectId;           // Primary key (auto-generated by MongoDB)
  shareId: string;         // Unique 9-character alphanumeric identifier for URL
  title: string;           // User-provided list title
  createdAt: Date;         // Timestamp when list was created
  updatedAt: Date;         // Timestamp of last modification
}
```

**Indexes**:
- **Primary**: `_id` (automatic, unique)
- **Unique**: `shareId` (unique index for fast lookup by URL)

**Validation Rules**:
- `shareId`: Must be exactly 9 characters, alphanumeric lowercase (a-z, 0-9)
- `title`: Non-empty string, max 200 characters
- `createdAt`: Auto-set on creation, immutable
- `updatedAt`: Auto-set on creation and update

**Example Document**:
```json
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "shareId": "abc123xyz",
  "title": "Team Sprint Tasks",
  "createdAt": ISODate("2026-01-05T10:00:00.000Z"),
  "updatedAt": ISODate("2026-01-05T10:30:00.000Z")
}
```

---

### TodoItem Collection

**Purpose**: Stores individual tasks within a list.

**Schema**:

```typescript
interface TodoItemDocument {
  _id: ObjectId;           // Primary key (auto-generated by MongoDB)
  listId: ObjectId;        // Foreign key reference to TodoList._id
  text: string;            // Task description
  completed: boolean;      // Completion status
  order: number;           // Sort order (integer, gaps allowed)
  createdAt: Date;         // Timestamp when item was created
  updatedAt: Date;         // Timestamp of last modification
}
```

**Indexes**:
- **Primary**: `_id` (automatic, unique)
- **Index**: `listId` (for efficient queries by list)
- **Compound Index**: `(listId, order)` (for efficient sorted retrieval)

**Validation Rules**:
- `listId`: Must reference valid TodoList._id
- `text`: Non-empty string, max 500 characters
- `completed`: Boolean (true or false)
- `order`: Non-negative integer
- `createdAt`: Auto-set on creation, immutable
- `updatedAt`: Auto-set on creation and update

**Example Document**:
```json
{
  "_id": ObjectId("507f1f77bcf86cd799439012"),
  "listId": ObjectId("507f1f77bcf86cd799439011"),
  "text": "Review pull requests",
  "completed": false,
  "order": 0,
  "createdAt": ISODate("2026-01-05T10:05:00.000Z"),
  "updatedAt": ISODate("2026-01-05T10:05:00.000Z")
}
```

---

## Relationships

```
TodoList (1) ──< (N) TodoItem
     │                  │
     └─────listId───────┘
```

- **One-to-Many**: One TodoList can have many TodoItems
- **Referential Integrity**: listId in TodoItem must reference existing TodoList._id
- **Cascade Delete**: When a list is deleted (future feature), all associated items should be deleted

---

## Queries

### Common Query Patterns

**1. Get list by shareId**:
```javascript
db.TodoList.findOne({ shareId: "abc123xyz" })
```

**2. Get all items for a list (ordered)**:
```javascript
db.TodoItem.find({ listId: ObjectId("...") }).sort({ order: 1 })
```

**3. Create new list**:
```javascript
db.TodoList.insertOne({
  shareId: generateShareId(),
  title: "New List",
  createdAt: new Date(),
  updatedAt: new Date()
})
```

**4. Add item to list**:
```javascript
// First, get max order
const maxOrder = await db.TodoItem.find({ listId: ObjectId("...") })
  .sort({ order: -1 })
  .limit(1)
  .toArray()

const nextOrder = maxOrder.length > 0 ? maxOrder[0].order + 100 : 0;

db.TodoItem.insertOne({
  listId: ObjectId("..."),
  text: "New task",
  completed: false,
  order: nextOrder,
  createdAt: new Date(),
  updatedAt: new Date()
})
```

**5. Toggle item completion**:
```javascript
db.TodoItem.updateOne(
  { _id: ObjectId("...") },
  { 
    $set: { 
      completed: true,
      updatedAt: new Date()
    }
  }
)
```

**6. Delete item**:
```javascript
db.TodoItem.deleteOne({ _id: ObjectId("...") })
```

**7. Update list metadata**:
```javascript
db.TodoList.updateOne(
  { _id: ObjectId("...") },
  { 
    $set: { 
      title: "Updated Title",
      updatedAt: new Date()
    }
  }
)
```

---

## TypeScript Interfaces

**Database Layer** (`lib/db-types.ts`):

```typescript
import { ObjectId } from 'mongodb';

// Document types (database representation)
export interface TodoListDocument {
  _id: ObjectId;
  shareId: string;
  title: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface TodoItemDocument {
  _id: ObjectId;
  listId: ObjectId;
  text: string;
  completed: boolean;
  order: number;
  createdAt: Date;
  updatedAt: Date;
}
```

**API Layer** (serialized for JSON):

```typescript
// API response types (ObjectId → string, Date → ISO string)
export interface TodoList {
  _id: string;
  shareId: string;
  title: string;
  createdAt: string;
  updatedAt: string;
}

export interface TodoItem {
  _id: string;
  text: string;
  completed: boolean;
  order: number;
  createdAt: string;
  updatedAt: string;
}
```

---

## Database Initialization

**Create Collections and Indexes**:

```javascript
// Run this script once to set up the database
db.createCollection("TodoList");
db.createCollection("TodoItem");

// TodoList indexes
db.TodoList.createIndex({ shareId: 1 }, { unique: true });

// TodoItem indexes
db.TodoItem.createIndex({ listId: 1 });
db.TodoItem.createIndex({ listId: 1, order: 1 });
```

**MongoDB Shell Commands**:
```bash
mongosh mongodb://localhost:27017/collab-todo

use collab-todo
db.createCollection("TodoList")
db.createCollection("TodoItem")
db.TodoList.createIndex({ shareId: 1 }, { unique: true })
db.TodoItem.createIndex({ listId: 1 })
db.TodoItem.createIndex({ listId: 1, order: 1 })
```

---

## Data Lifecycle

### Creation Flow
1. User creates list → Generate unique shareId → Insert into TodoList collection
2. User adds task → Calculate next order value → Insert into TodoItem collection

### Update Flow
1. User modifies task → Update TodoItem document → Set updatedAt timestamp
2. User modifies list title → Update TodoList document → Set updatedAt timestamp

### Deletion Flow
1. User deletes task → Remove TodoItem document (no cascade effects)
2. (Future) User deletes list → Remove TodoList and all associated TodoItems

### Synchronization Flow
1. Client polls every 5 seconds → GET /api/lists/[shareId]
2. API fetches TodoList by shareId → Fetches all TodoItems by listId (sorted)
3. Returns combined response → Client updates UI if data changed

---

## Scalability Considerations

### Current Design (v1)
- **Lists**: Expected <1000 lists initially
- **Items per list**: Expected 10-50 items per list
- **Concurrent users**: 10+ users per list supported
- **Indexes**: Efficient lookups by shareId and listId

### Future Optimizations
- **Pagination**: If lists grow >1000 items, implement cursor-based pagination
- **Caching**: Add Redis cache for frequently accessed lists
- **Sharding**: If scale exceeds single server, shard by shareId
- **Archival**: Move inactive lists to cold storage after N days

### Query Performance
- `shareId` lookup: O(1) with unique index
- Items by `listId`: O(log N) with index + O(M) to retrieve M items
- Sorted retrieval: O(M log M) but mitigated by compound index

---

## Data Integrity

### Validation (Application Layer)
- Enforce max lengths (title: 200 chars, text: 500 chars)
- Validate shareId format (9-char alphanumeric lowercase)
- Check listId references exist before inserting items
- Prevent empty strings for required fields

### MongoDB Schema Validation (Optional Future Enhancement)
```javascript
db.createCollection("TodoList", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["shareId", "title", "createdAt", "updatedAt"],
      properties: {
        shareId: { bsonType: "string", pattern: "^[a-z0-9]{9}$" },
        title: { bsonType: "string", minLength: 1, maxLength: 200 },
        createdAt: { bsonType: "date" },
        updatedAt: { bsonType: "date" }
      }
    }
  }
})
```

---

## Migration Path (Future)

### Adding User Accounts
```typescript
interface TodoListDocument {
  _id: ObjectId;
  shareId: string;
  title: string;
  ownerId?: ObjectId;        // NEW: Reference to User collection
  permissions?: Permission[]; // NEW: Array of user permissions
  createdAt: Date;
  updatedAt: Date;
}
```

### Adding Rich Metadata
```typescript
interface TodoItemDocument {
  _id: ObjectId;
  listId: ObjectId;
  text: string;
  completed: boolean;
  order: number;
  dueDate?: Date;            // NEW: Optional due date
  priority?: 'low' | 'medium' | 'high'; // NEW: Priority level
  tags?: string[];           // NEW: Array of tags
  createdAt: Date;
  updatedAt: Date;
}
```

All migrations are additive (optional fields) to maintain backward compatibility.

---

## Summary

- **2 Collections**: TodoList (metadata), TodoItem (tasks)
- **3 Indexes**: TodoList.shareId (unique), TodoItem.listId, TodoItem.(listId, order)
- **Relationships**: 1:N (TodoList → TodoItem)
- **Type Safety**: TypeScript interfaces for all documents
- **Performance**: Optimized for primary query patterns (lookup by shareId, fetch items by listId)
- **Extensibility**: Schema allows future additions without breaking changes
